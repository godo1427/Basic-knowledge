# Quick Sort

* 분할 정복(divide and conquer)에 근거하여 만들어진 정렬 방법이다.
* 분할 정복(divide and conquer) 방법
  * 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
* 평균적으로 매우 빠른 속도를 보이는 알고리즘이다.



### 이해와 구현

오름차순을 기준으로 한다.

* 퀵정렬의 대상이 되는 배열

  * ​	5		1		3		7		9		2		4		6		8
  * ​      left                                                                                                                         right
  * ​    pivot        low                                                                                                          high

* 구현과정에서 실제로 사용할 이름

  * left: 정렬 대상의 가장 왼쪽 지점을 가리키는 이름
  * right: 정렬 대상의 가장 오른쪽 지점을 가리키는 이름
  * pivot: 정렬을 할 때, 일종의 기준
  * low: 피벗을 제외한 가장 왼쪽에 위치한 지점을 가리키는 이름
  * high: 피벗을 제외한 가장 오른쪽에 위치한 지점을 가리키는 이름

* low는 오른쪽으로 high는 왼쪽으로 이동시킨다.

  * 이동의 기준

  * low의 오른쪽 방향 이동: 피벗보다 큰 값을 만날 때 까지

  * high의 왼쪽 방향 이동: 피벗보다 작은 값을 만날 때 까지

* low는 7이 저장된 위치에 머물고, high는 4가 저장된 위치에 머문다. 이 때, 이 둘이 가리키는 데이터를 서로 교환 하여 다음과 같은 상태가 되게 한다.

  * ​	5		1		3		4		9		2		7		6		8
  * ​      left                                                                                                                         right
  * ​    pivot                                         low                                          high

* 7과 4의 교환 후에도 계속해서 low는 오른쪽으로 high는 왼쪽으로 이동한다. 

* 마찬가지로 low는 피벗보다 큰 값을 찾고, high는 피벗보다 작은 값을 찾는다.

* low와 high는 각각 9와 2를 가리키게 되고, 이 둘을 교환 하여 다음과 같은 상태가 되게 한다.

  * ​	5		1		3		4		2		9		7		6		8
  * ​      left                                                                                                                         right
  * ​    pivot                                                        low          high

* 교환 후에도 low는 피벗보다 큰 값을 찾을 때 까지 오른쪽으로, high는 피벗보다 작은 값을 찾을 때까지 왼쪽으로 이동해 나간다. 그러면 결국에는 low와 high가 가리키는 위치가 교차되는 상황이 발생한다.

  * 이때는 low와 high가 가리키는 값을 교환하지 않는다. 이 상황은 low와 high의 이동 및 교환의 과정이 완료되었음을 의미한다. 

  * 따라서 이번에는 pivot과 high가 가리키는 데이터를 서로 교환하여 다음 그림의 상태가 되게 한다.

    * ​	2		1		3		4		5		9		7		6		8
    * ​      left                                                                                                                         right
    * ​    pivot                                                         high         low

* 피벗이었던 5가 정렬되었을 때의 제 위치를 찾게 되었다.
* 5의 왼쪽에는 5보다 작은 값들이 위치하고 오른편에는 5보다 큰 값들이 위치하고 있다.
* 다음 단계는 다음과 같이 진행된다.
  * ​	2		1		3		4		**5**		9		7		6		8
  * ​      left                                         right                         left                                         right
  * ​    pivot                                                                         pivot
* 위 그림에서 보이듯이, 제자리를 찾은 5을 기준으로 왼쪽 영역과 오른쪽 영역을 대상으로 지금 설명한 과정을 반복하게 된다. 그러면 왼쪽영역의 pivot인 2와 오른쪽영역의 pivot인 9가 제 자리를 찾을 것이다. 
* 그리고 이어서, 제자리를 찾은 2를 기준으로 나뉘는 왼쪽 영역과 오른쪽 영역을 대상으로, 제자리를 찾은 9의 왼쪽 영역과 오른쪽 영역을 대상으로, 퀵 정렬의 기본 과정을 반복해 나간다.
* 이 과정은 left와 right가 각각 정렬 대상의 시작과 끝을 의미하므로 left > right (left와 right가 교차되는 상황)에 놓이게 될 때 더 이상 정렬할 대상이 없다는 의미가 된다.



### 퀵 정렬 알고리즘의 특징

* 장점
  * 속도가 빠르다.
    * 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
  * 추가 메모리 공간을 필요로 하지 않는다.
    * 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
* 단점
  * 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
* 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.






​                

****

[참고 영상](https://www.youtube.com/watch?v=cnzIChso3cc)

***

