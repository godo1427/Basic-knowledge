# Bubble Sort

 서로 인접한 두 값을 비교하여 정렬하는 알고리즘이다.

* 인접한 두 값을 차례로 비교하여 만약 순서대로 되어있지않으면 교환한다.



## 장단점

* 장점
  * 이해하기 쉽고 코드가 단순하여 구현하기 쉽다.
* 단점
  * 속도가 느리다.
  * 하나의 요소가  가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 모든 다른 요소들과 교환해야 한다.
  * 이미 최종 정렬위치에 있는 경우라도 모든 배열의 요소와 비교하여야한다.
  *   비교할 데이터의 개수가 많을 수록 성능이 저하된다.
    * 그래서 보통 데이터의 개수가 적은 경우에 주로 사용한다.



## 정렬 과정

6,  4 , 9, 8, 1을 Bubble sort를 이용하여 오름차순으로 정렬해보겠다.

**첫 번째 순회**

1.  먼저 6과 4를 비교한다. 6이 더 크므로 6과 4를 교환한다.
   * 4, 6, 9, 8, 1
2.  오른 쪽으로 한 칸 이동하여 6과 9를 비교한다.  이미 큰 수과 뒤에 있으므로 교환하지 않는다.
   * 4, 6, 9, 8, 1
3. 다시 오른 쪽으로 한 칸 이동하여 9와 8을 비교한다. 9가 더 크므로 9와 8을 교환한다.
   * 4, 6, 8, 9, 1
4. 다시 오른 쪽으로 한 칸 이동하여 9와 1을 비교한다. 9가 더 크므로 9와 1을 교환한다.
   * 4, 6, 8, 1, 9

* 이것이 한 번의 순회이다.
* 모든 원소를 비교 또는 교환한 결과 가장 큰 수가 파도처럼 밀려 맨 마지막, 최종 정렬 위치에 도착한다.

* 다음번 순회 부터는 이미 정렬된 원소들을 제외한 원소들만 방문하여 된다. 
* 한 번 순회할 때 마다 비교 횟수가 1씩 줄어든다.

**두 번째 순회**

1. 4와 6을 비교한다. 이미 큰 수가 뒤에 있으므로 교환하지 않는다.
   * 4, 6, 8, 1, 9
2. 오른 쪽으로 한 칸 이동하여 6과 8을 비교한다. 이미 큰 수가 뒤에 있으므로 교환하지 않는다.
   * 4, 6, 8, 1, 9
3. 다시 오른 쪽으로 한 칸 이동하여 8과 1을 비교하여 8이 더 크므로 8과 1을 교환한다.
   * 4, 6, 1, 8, 9

* 두 번째 순회를 통해 나머지 원소중 가장 큰 원소인 8이 최종 정렬 위치에 도착한다.

**세 번째  순회**

1. 4와 6을 비교한다. 이미 큰 수가 뒤에 있으므로 교환하지 않는다.
   *  4, 6, 1, 8, 9
2. 오른 쪽으로 한 칸 이동하여 6과 1을 비교한다. 6이 더 크므로 6과 1을 교환한다.
   * 4, 1, 6, 8, 9

* 세 번째 순회를 통해 나머지 원소중 가장 큰 원소인 6이 최종 정렬 위치에 도착한다.

**네 번째 순회**

1. 4와 1을 비교하여 4가 더 큰 수 이므로 4와 1을 교환한다.
   * 1, 4, 6, 8, 9

* 모든 수가 최종 정렬 위치에 도착하게 된다. [1, 4, 6, 8, 9]

## 시간 복잡도

* 비교 횟수
  * 한 번 순회 할 때 마다 비교할 대상이 하나 씩 줄어들기 때문에 전체 원소의 개수가 n개라 할 때 n-1번 순회하면 정렬이 끝난다.
  * 수식: (n-1) + (n-2) + ... + 2 + 1 = (n-1) * n/2 
* 교환 횟수
  * 최악의 경우 원소를 비교할 때 마다 교환이 일어나므로 비교 횟수와 같이 (n-1) * n/2이다.



따라서 평균적으로 O(n^2)시간 복잡도를 가지게 된다.