# 상호배제 알고리즘



## 데커(Dekker) 알고리즘

 데커 알고리즘은 flag와 turn이라는 변수로 임계영역에 들어갈 프로세스를 결정하는 방식이다.

flag: 프로세스 중 누가 임계영역에 진입할 것인지 나타낸다.                                                 

turn: 누가 임계영역에 들어갈 차례인지 나타낸다.

```C
while(1) {
  flag[i] = true;     // 프로세스 i가 임계영역 진입을 시도한다.
    
  while(flag[j]) {    // 프로세스 j가 현재 임계영역에 있는지 확인한다.
    if(turn == j) {     // 프로세스 j가 임계영역을 사용 중이라면
	   flag[i] = false;    // 프로세스 i의 진입을 취소하고,  
     while (turn == j);  // turn이 j에서 바뀔 때 까지 기다린다...                                  flag[i] = true;     // j의 turn이 아니면, 즉 임계영역에서 j가 나오면 재진입을 시도한다.
    }
  }
}

/*이 부분은 임계영역이다*/

...

turn = j;           // 임계영역의 사용이 끝나면, turn을 넘긴다
flag[i] = false;    // 진입 flag값을 false로 바꾸어 임계영역 사용 완료를 알린다.

...

}
```



##  피터슨(Peterson) 알고리즘

 데커 알고리즘과 유사 하지만 상대방(다른 프로세서 또는 스레드)에게 진입기회를 양보한다는 차이가 있다.

```c
while(1) {
  flag[i] = true;            // 프로세스i가 임계영역에 진입을 시도
  turn = j;                  // 다른 프로세스에 진입 기회를 양보
  while(flag[i] && turn==j); // 다른 프로세스가 진입을 시도하면 대기 아니면 진입
/* 이곳은 임계영역이다. */
...
flag[i] = false;           // 임계영역 사용 완료
...
}


```



## 제과점(Bakery) 알고리즘

 데커 알고리즘, 피터슨 알고리즘과 달리 여러 개의 프로세스(또는 스레드)에 대한 처리가 가능한다. 

```c
while(1) {
...
  isReady[i] = true;                 // 번호표를 받을 준비
  number[i] = max(number[0~n-1]) +1  // 현재 실행 중인 프로세스 중 가장 큰 번호로 배정
  isReady[i] = false;                // 번호표 수령 완료
 
  for( j =0; j < n; j++ ) {          // 모든 프로세스에 대해 번호표를 비교한다.
    while( isReady[j] );               // 비교할 프로세스가 번호표를 받을 때까지 대기
    while(number[j] && number[j] < number[i] && j<i);
// 프로세스 j가 번호표를 가지고 있고,
// 프로세스 j의 번호표가 프로세스i의 번호표보다 작거나 같을 경우
// j가 i보다 작다면(프로세스 j가 i보다 먼저 온 프로세스이면)
// 프로세스 j의 종료(number[j]=0)까지 대기
}
/* 이곳은 임계영역이다. */
...
number[i] = 0;                     // 임계영역 사용 완료
...
}
```